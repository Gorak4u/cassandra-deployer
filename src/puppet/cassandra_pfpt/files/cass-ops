#!/usr/bin/env python3
# This file is managed by Puppet.
# A production-grade, unified operations script for Apache Cassandra.

import sys
import argparse
import subprocess
import os
from typing import Dict, Any, List

try:
    from colorama import Fore, Style, init
    init(autoreset=True)
    COLOR_ENABLED = True
except ImportError:
    # Create dummy Fore and Style objects if colorama is not installed
    class DummyColor:
        def __getattr__(self, name: str) -> str:
            return ""
    Fore = DummyColor()
    Style = DummyColor()
    COLOR_ENABLED = False


# --- Script Configuration ---
# This dictionary maps the CLI command to the underlying script and its help text.
SUBCOMMANDS: Dict[str, Dict[str, Any]] = {
    # Status & Health Checks
    'health': {
        'script': '/usr/local/bin/node_health_check.sh',
        'help': 'Run a comprehensive health check on the local node.',
        'group': 'Status & Health Checks'
    },
    'cluster-health': {
        'script': '/usr/local/bin/cluster-health.sh',
        'help': 'Quickly check cluster connectivity and nodetool status.',
        'group': 'Status & Health Checks'
    },
    'disk-health': {
        'script': '/usr/local/bin/disk-health-check.sh',
        'help': 'Check disk usage against warning/critical thresholds.',
        'group': 'Status & Health Checks'
    },
    'version': {
        'script': '/usr/local/bin/version-check.sh',
        'help': 'Audit and print versions of key software (OS, Java, Cassandra).',
        'group': 'Status & Health Checks'
    },
    'upgrade-check': {
        'script': '/usr/local/bin/cassandra-upgrade-precheck.sh',
        'help': 'Run pre-flight checks before a major version upgrade.',
        'group': 'Status & Health Checks'
    },
    # Node Lifecycle & Maintenance
    'stop': {
        'script': '/usr/local/bin/stop-node.sh',
        'help': 'Safely drain and stop the Cassandra service.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'restart': {
        'script': '/usr/local/bin/rolling_restart.sh',
        'help': 'Perform a safe, rolling restart of the Cassandra service.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'reboot': {
        'script': '/usr/local/bin/reboot-node.sh',
        'help': 'Safely drain Cassandra and reboot the machine.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'drain': {
        'script': '/usr/local/bin/drain-node.sh',
        'help': 'Drain the node, flushing memtables and stopping client traffic.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'decommission': {
        'script': '/usr/local/bin/decommission-node.sh',
        'help': 'Permanently remove this node from the cluster after streaming its data.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'replace': {
        'script': '/usr/local/bin/prepare-replacement.sh',
        'help': 'Configure this NEW, STOPPED node to replace a dead node.',
        'group': 'Node Lifecycle & Maintenance'
    },
    'rebuild': {
        'script': '/usr/local/bin/rebuild-node.sh',
        'help': 'Rebuild the data on this node by streaming from another datacenter.',
        'group': 'Node Lifecycle & Maintenance'
    },
    # Data Management & Repair
    'repair': {
        'script': '/usr/local/bin/range-repair.sh',
        'help': 'Run a safe, granular repair on the node\'s token ranges.',
        'group': 'Data Management & Repair'
    },
    'cleanup': {
        'script': '/usr/local/bin/cleanup-node.sh',
        'help': 'Run \'nodetool cleanup\' with safety checks.',
        'group': 'Data Management & Repair'
    },
    'compact': {
        'script': '/usr/local/bin/compaction-manager.sh',
        'help': 'Run \'nodetool compact\' with safety checks.',
        'group': 'Data Management & Repair'
    },
    'garbage-collect': {
        'script': '/usr/local/bin/garbage-collect.sh',
        'help': 'Run \'nodetool garbagecollect\' with safety checks.',
        'group': 'Data Management & Repair'
    },
    'upgrade-sstables': {
        'script': '/usr/local/bin/upgrade-sstables.sh',
        'help': 'Run \'nodetool upgradesstables\' with safety checks.',
        'group': 'Data Management & Repair'
    },
    # Backup & Recovery
    'backup': {
        'script': '/usr/local/bin/full-backup-to-s3.sh',
        'help': 'Manually trigger a full, node-local backup to S3.',
        'group': 'Backup & Recovery'
    },
    'incremental-backup': {
        'script': '/usr/local/bin/incremental-backup-to-s3.sh',
        'help': 'Manually trigger an incremental backup to S3.',
        'group': 'Backup & Recovery'
    },
    'backup-status': {
        'script': '/usr/local/bin/backup-status.sh',
        'help': 'Check the status of the last completed backup for a node.',
        'group': 'Backup & Recovery'
    },
    'snapshot': {
        'script': '/usr/local/bin/take-snapshot.sh',
        'help': 'Take an ad-hoc snapshot with a generated tag.',
        'group': 'Backup & Recovery'
    },
    'restore': {
        'script': '/usr/local/bin/restore-from-s3.sh',
        'help': 'Restore data from S3 backups. Run \'cass-ops restore --help\' for usage.',
        'group': 'Backup & Recovery'
    },
    # Advanced & Destructive Operations
    'assassinate': {
        'script': '/usr/local/bin/assassinate-node.sh',
        'help': 'Forcibly remove a dead node from the cluster\'s gossip ring.',
        'group': 'Advanced & Destructive Operations'
    },
    # Performance Testing
    'stress': {
        'script': '/usr/local/bin/stress-test.sh',
        'help': 'Run \'cassandra-stress\' via a robust wrapper. Run \'cass-ops stress --help\' for usage.',
        'group': 'Performance Testing'
    },
    # Documentation
    'manual': {
        'script': '/usr/local/bin/cassandra-manual.sh',
        'help': 'Display the interactive operations manual in the terminal.',
        'group': 'Documentation'
    },
    'backup-guide': {
        'script': '/usr/share/doc/cassandra_pfpt/BACKUP_AND_RECOVERY_GUIDE.md',
        'is_doc': True,
        'help': 'Display the comprehensive backup and recovery guide.',
        'group': 'Documentation'
    },
}

# --- Helper Functions for Printing ---

def print_info(message):
    print(f"{Fore.BLUE}{Style.BRIGHT}[INFO]{Style.RESET_ALL} {message}")

def print_error(message):
    print(f"{Fore.RED}{Style.BRIGHT}[ERROR]{Style.RESET_ALL} {message}", file=sys.stderr)

def create_custom_formatter(prog):
    """Creates a custom argparse formatter to group commands."""
    class GroupedHelpFormatter(argparse.HelpFormatter):
        def _format_action(self, action):
            # Default formatting for everything except the subparser
            if not isinstance(action, argparse._SubParsersAction):
                return super()._format_action(action)
            
            # Group subcommands
            groups: Dict[str, List[str]] = {}
            for sub_action in self._iter_indented_subactions(action):
                cmd = sub_action.dest
                group_name = SUBCOMMANDS.get(cmd, {}).get('group', 'Miscellaneous')
                if group_name not in groups:
                    groups[group_name] = []
                help_text = self._get_help_string(sub_action)
                groups[group_name].append(f"  {cmd:<20} {help_text}")

            # Format the groups
            output = []
            sorted_groups = sorted(groups.keys(), key=lambda g: (
                'Status' not in g, 
                'Lifecycle' not in g,
                'Data' not in g,
                'Backup' not in g,
                g
            ))
            for group_name in sorted_groups:
                output.append(f"\n  {Fore.GREEN}{group_name}:{Style.RESET_ALL}")
                output.extend(groups[group_name])
            
            return "\n".join(output)

    return GroupedHelpFormatter

def main():
    """Main entry point for the script."""

    parser = argparse.ArgumentParser(
        description=f"{Style.BRIGHT}Unified operations script for Apache Cassandra.{Style.RESET_ALL}\nThis script acts as a dispatcher to the underlying operational shell scripts.",
        epilog="Run '<command> --help' for specific command options.",
        formatter_class=create_custom_formatter,
        add_help=False # We handle help manually to show groups
    )
    # Custom help action
    parser.add_argument(
        '-h', '--help',
        action='help',
        default=argparse.SUPPRESS,
        help='Show this help message and exit'
    )
    
    subparsers = parser.add_subparsers(dest='command', title='Available Commands')

    for cmd, details in SUBCOMMANDS.items():
        subparsers.add_parser(
            cmd,
            help=details['help'],
            add_help=False # Pass '--help' to the subcommand script itself
        )

    # If no command is given, print help and exit.
    if len(sys.argv) == 1:
        parser.print_help(sys.stdout)
        sys.exit(0)
    
    # The first parse just identifies the command without consuming other args
    args, remaining_args = parser.parse_known_args()

    if not args.command:
        parser.print_help(sys.stderr)
        sys.exit(1)

    cmd_details = SUBCOMMANDS.get(args.command)
    if not cmd_details:
        print_error(f"Unknown command '{args.command}'")
        sys.exit(1)

    # Special handling for documentation commands
    if cmd_details.get('is_doc'):
        doc_path = cmd_details['script']
        if not os.path.exists(doc_path):
            print_error(f"Documentation file not found at {doc_path}")
            sys.exit(1)
        try:
            # Use `less -R` to correctly render color codes in the manual
            subprocess.run(['less', '-R', doc_path], check=True)
        except FileNotFoundError:
            print_error("`less` command not found. Cannot display documentation.")
            sys.exit(1)
        except subprocess.CalledProcessError:
            # This can happen if user quits `less` with `q` then an error code is returned. Ignore.
            pass
        sys.exit(0)

    # Execute the underlying script
    script_path = cmd_details['script']
    if not os.path.exists(script_path) or not os.access(script_path, os.X_OK):
        print_error(f"Script for command '{args.command}' not found or not executable at {script_path}")
        sys.exit(1)

    command_to_run = [script_path] + remaining_args
    
    try:
        # Use execv to replace the current process with the new one.
        # This makes signal handling (like Ctrl+C) work correctly.
        os.execv(command_to_run[0], command_to_run)
    except Exception as e:
        print_error(f"Failed to execute command '{args.command}': {e}")
        sys.exit(1)


if __name__ == "__main__":
    if os.geteuid() != 0:
        print_error("This script must be run as root or with sudo.")
        sys.exit(1)
    main()
