#!/usr/bin/env python3
# This file is managed by Puppet.

import sys
import subprocess
import argparse

# Make colorama optional for robustness
try:
    import colorama
    colorama.init(autoreset=True)
    COLOR_ENABLED = True
except ImportError:
    COLOR_ENABLED = False

SCRIPT_MAP = {
    'health': 'node_health_check.sh',
    'cluster-health': 'cluster-health.sh',
    'disk-health': 'disk-health-check.sh',
    'version': 'version-check.sh',
    'stop': 'stop-node.sh',
    'restart': 'rolling_restart.sh',
    'reboot': 'reboot-node.sh',
    'drain': 'drain-node.sh',
    'decommission': 'decommission-node.sh',
    'replace': 'prepare-replacement.sh',
    'rebuild': 'rebuild-node.sh',
    'repair': 'range-repair.sh',
    'cleanup': 'cleanup-node.sh',
    'compact': 'compaction-manager.sh',
    'garbage-collect': 'garbage-collect.sh',
    'upgrade-sstables': 'upgrade-sstables.sh',
    'backup': 'full-backup-to-s3.sh',
    'incremental-backup': 'incremental-backup-to-s3.sh',
    'backup-status': 'backup-status.sh',
    'snapshot': 'take-snapshot.sh',
    'restore': 'restore-from-s3.sh',
    'assassinate': 'assassinate-node.sh',
    'stress': 'stress-test.sh',
    'manual': 'cassandra-manual.sh',
    'upgrade-check': 'cassandra-upgrade-precheck.sh',
}

SCRIPT_DIR = '/usr/local/bin'

def log_message(message, level="INFO"):
    """Logs a message with a timestamp and level."""
    color_map = {
        "INFO": "",
        "SUCCESS": "",
        "WARN": "",
        "ERROR": "",
    }
    if COLOR_ENABLED:
        color_map = {
            "INFO": colorama.Fore.BLUE,
            "SUCCESS": colorama.Fore.GREEN,
            "WARN": colorama.Fore.YELLOW,
            "ERROR": colorama.Fore.RED,
        }
    
    timestamp = subprocess.check_output(['date', "+%Y-%m-%d %H:%M:%S"], text=True).strip()
    print(f"{color_map.get(level, '')}[{timestamp}] [{level}] {message}")


def main():
    parser = argparse.ArgumentParser(
        description="Unified operations script for Cassandra.",
        epilog="This script acts as a dispatcher to the underlying operational shell scripts."
    )
    parser.add_argument(
        'command', 
        choices=SCRIPT_MAP.keys(), 
        help="The operational command to execute."
    )
    parser.add_argument(
        'args', 
        nargs=argparse.REMAINDER, 
        help="Arguments to pass to the underlying script."
    )

    args = parser.parse_args()
    
    command = args.command
    script_name = SCRIPT_MAP.get(command)
    
    if not script_name:
        log_message(f"Unknown command: {command}", level="ERROR")
        sys.exit(1)
        
    script_path = f"{SCRIPT_DIR}/{script_name}"
    
    try:
        # Construct the full command to execute
        full_command = [script_path] + args.args
        log_message(f"Executing command: {' '.join(full_command)}", level="INFO")
        
        # Execute the script
        result = subprocess.run(full_command, check=True, text=True)
        
        log_message(f"Command '{command}' completed successfully.", level="SUCCESS")
        sys.exit(0)
        
    except FileNotFoundError:
        log_message(f"Script not found at {script_path}", level="ERROR")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        log_message(f"Command '{command}' failed with exit code {e.returncode}.", level="ERROR")
        sys.exit(e.returncode)
    except Exception as e:
        log_message(f"An unexpected error occurred: {e}", level="ERROR")
        sys.exit(1)

if __name__ == "__main__":
    if sys.version_info < (3, 6):
        sys.exit("This script requires Python 3.6 or newer.")
    main()
