#!/usr/bin/env python3
# This file is managed by Puppet.

import argparse
import sys
import subprocess

# --- Colorama Handling ---
# This section ensures that the script can run even if colorama is not installed,
# by providing dummy objects that do nothing.
try:
    import colorama
    colorama.init()
    Color = colorama.Fore
    Style = colorama.Style
except ImportError:
    class DummyColor:
        def __getattr__(self, name):
            return ""
    class DummyStyle:
        def __getattr__(self, name):
            return ""
    Color = DummyColor()
    Style = DummyStyle()


def print_color(text, color):
    """Prints text in a given color to stderr to not interfere with script output."""
    print(f"{color}{text}{Style.RESET_ALL}", file=sys.stderr)


def get_script_path(command):
    """Maps a command to its underlying shell script."""
    script_map = {
        "health": "node_health_check.sh",
        "cluster-health": "cluster-health.sh",
        "disk-health": "disk-health-check.sh",
        "version": "version-check.sh",
        "stop": "stop-node.sh",
        "restart": "rolling_restart.sh",
        "reboot": "reboot-node.sh",
        "drain": "drain-node.sh",
        "decommission": "decommission-node.sh",
        "replace": "prepare-replacement.sh",
        "rebuild": "rebuild-node.sh",
        "repair": "range-repair.sh",
        "cleanup": "cleanup-node.sh",
        "compact": "compaction-manager.sh",
        "garbage-collect": "garbage-collect.sh",
        "upgrade-sstables": "upgrade-sstables.sh",
        "backup": "full-backup-to-s3.sh",
        "incremental-backup": "incremental-backup-to-s3.sh",
        "backup-status": "backup-status.sh",
        "snapshot": "take-snapshot.sh",
        "restore": "restore-from-s3.sh",
        "assassinate": "assassinate-node.sh",
        "stress": "stress-test.sh",
        "manual": "cassandra-manual.sh",
        "upgrade-check": "cassandra-upgrade-precheck.sh",
    }
    script_name = script_map.get(command)
    if script_name:
        return f"/usr/local/bin/{script_name}"
    return None


def main():
    """Main function to parse arguments and dispatch to the correct script."""

    # --- Manually build the help text for perfect formatting ---
    command_width = 22  # Padded width for the command column
    help_groups = {
        "Status & Health Commands": {
            'health': "Run a comprehensive health check on the local node.",
            'cluster-health': "Quickly check cluster connectivity and nodetool status.",
            'disk-health': "Check disk usage against warning/critical thresholds.",
            'version': "Audit and print versions of key software."
        },
        "Node Lifecycle & Maintenance": {
            'stop': "Safely drain and stop the Cassandra service.",
            'restart': "Perform a safe, rolling restart of the Cassandra service.",
            'reboot': "Safely drain Cassandra and reboot the machine.",
            'drain': "Drain the node, flushing memtables and stopping client traffic.",
            'decommission': "Permanently remove this node from the cluster.",
            'replace': "Configure this NEW, STOPPED node to replace a dead node.",
            'rebuild': "Rebuild the data on this node by streaming from another DC."
        },
        "Data Management & Repair": {
            'repair': "Run a safe, granular repair on the node's token ranges.",
            'cleanup': "Run 'nodetool cleanup' with safety checks.",
            'compact': "Run 'nodetool compact' with safety checks.",
            'garbage-collect': "Run 'nodetool garbagecollect' with safety checks.",
            'upgrade-sstables': "Run 'nodetool upgradesstables' with safety checks.",
            'snapshot': "Take an ad-hoc snapshot with a generated tag."
        },
        "Backup & Recovery": {
            'backup': "Manually trigger a full, node-local backup to S3.",
            'incremental-backup': "Manually trigger an incremental backup to S3.",
            'backup-status': "Check the status of the last completed backup for a node.",
            'restore': "Restore data from S3 backups. Use '-- --help' for complex options."
        },
        "Advanced & Destructive Operations": {
            'assassinate': "Forcibly remove a dead node from the cluster ring.",
            'stress': "Run 'cassandra-stress' via a robust wrapper.",
            'upgrade-check': "Run pre-flight checks before a major version upgrade."
        },
        "Documentation": {
            'manual': "Display the full operations manual in the terminal."
        }
    }
    
    description = f"{Style.BRIGHT}Unified operations script for Cassandra.{Style.RESET_ALL}\nProvides safe, robust wrappers for common operational tasks.\n\n"
    all_commands = []
    for title, commands in help_groups.items():
        description += f"{Style.BRIGHT}{title}:{Style.RESET_ALL}\n"
        for cmd, help_text in commands.items():
            all_commands.append(cmd)
            # Use fixed-width padding to ensure alignment
            description += f"  {cmd:<{command_width}}{help_text}\n"
        description += "\n"

    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="cass-ops [-h] <command> [args...]"
    )
    
    parser.add_argument(
        'command',
        choices=all_commands,
        metavar='<command>',
        help=argparse.SUPPRESS # Suppress from the main help as it's in the description
    )
    
    parser.add_argument(
        'args',
        nargs=argparse.REMAINDER,
        metavar='[args...]',
        help='Arguments to pass to the underlying script.'
    )
    
    # If no command is given, print the formatted help text and exit.
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)
        
    args = parser.parse_args()

    script_path = get_script_path(args.command)
    
    if not script_path:
        print_color(f"Error: Command '{args.command}' is not implemented.", Color.RED)
        sys.exit(1)

    try:
        command_to_run = [script_path] + args.args
        print_color(f"Executing: {' '.join(command_to_run)}", Color.YELLOW)
        print("-" * 60, file=sys.stderr)
        
        # Use Popen to stream output in real-time. This is better for long-running processes.
        process = subprocess.Popen(command_to_run, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
        
        for line in iter(process.stdout.readline, ''):
            print(line, end='')
        
        process.stdout.close()
        return_code = process.wait()

        print("-" * 60, file=sys.stderr)
        if return_code == 0:
            print_color(f"SUCCESS: Command '{args.command}' completed successfully.", Color.GREEN)
        else:
            print_color(f"ERROR: Command '{args.command}' failed with exit code {return_code}.", Color.RED)
        
        sys.exit(return_code)

    except FileNotFoundError:
        print_color(f"Error: The script for command '{args.command}' was not found at '{script_path}'.", Color.RED)
        sys.exit(127)
    except Exception as e:
        print_color(f"An unexpected error occurred: {e}", Color.RED)
        sys.exit(1)


if __name__ == '__main__':
    main()
