#!/usr/bin/env python3
# This file is managed by Puppet.
import sys
import subprocess
from collections import OrderedDict

try:
    from colorama import Fore, Style, init
    init(autoreset=True)
    
    C_RED = Fore.RED
    C_GREEN = Fore.GREEN
    C_YELLOW = Fore.YELLOW
    C_BLUE = Fore.BLUE
    C_BOLD = Style.BRIGHT
    C_RESET = Style.RESET_ALL
except ImportError:
    # If colorama is not installed, define colors as empty strings
    C_RED, C_GREEN, C_YELLOW, C_BLUE, C_BOLD, C_RESET = "", "", "", "", "", ""


# --- Command Definitions ---
# The OrderedDict preserves the order for the help message.
COMMANDS = OrderedDict([
    ('Documentation', {
        'manual': 'Display the full, interactive operations manual.',
        'backup-guide': 'Display the complete backup and recovery operations guide.',
        'puppet-guide': 'Display the Puppet architecture and automation guide.',
    }),
    ('Node & Cluster Status', {
        'health': 'Run a comprehensive health check on the local node.',
        'cluster-health': 'Quickly check cluster connectivity and nodetool status.',
        'disk-health': 'Check disk usage against warning/critical thresholds. Usage: disk-health [-p /path] [-w 80] [-c 90]',
        'version': 'Audit and print versions of key software (OS, Java, Cassandra).',
        'upgrade-check': 'Run pre-flight checks before a major version upgrade.',
    }),
    ('Node Lifecycle & Maintenance', {
        'stop': 'Safely drain and stop the Cassandra service.',
        'restart': 'Perform a safe, rolling restart of the Cassandra service.',
        'reboot': 'Safely drain Cassandra and reboot the machine.',
        'drain': 'Drain the node, flushing memtables and stopping client traffic.',
        'decommission': 'Permanently remove this node from the cluster after streaming its data.',
        'replace': 'Configure this NEW, STOPPED node to replace a dead node. Usage: replace <dead_node_ip>',
        'rebuild': 'Rebuild the data on this node by streaming from another datacenter. Usage: rebuild <source_dc>',
    }),
    ('Data Management & Repair', {
        'repair': 'Run a safe, granular repair on the node\'s token ranges. Usage: repair [<keyspace>]',
        'cleanup': 'Run \'nodetool cleanup\' with safety checks.',
        'compact': 'Run \'nodetool compact\' with safety checks. Usage: compact [-k keyspace] [-t table]',
        'garbage-collect': 'Run \'nodetool garbagecollect\' with safety checks.',
        'upgrade-sstables': 'Run \'nodetool upgradesstables\' with safety checks after a major version upgrade.',
    }),
    ('Backup & Recovery', {
        'backup': 'Manually trigger a full, node-local backup to S3.',
        'incremental-backup': 'Manually trigger an incremental backup to S3.',
        'backup-status': 'Check the status of the last completed backup. Usage: backup-status [--source-host <hostname>]',
        'snapshot': 'Take an ad-hoc snapshot with a generated tag. Usage: snapshot [<keyspaces>]',
        'restore': 'Restore data from S3. Run \'restore -- --help\' for all options.',
    }),
    ('Advanced & Destructive Operations', {
        'assassinate': 'Forcibly remove a dead node from the cluster\'s gossip ring. Usage: assassinate <dead_node_ip>',
    }),
    ('Performance Testing', {
        'stress': 'Run \'cassandra-stress\' via a robust wrapper. Run \'stress -- --help\' for options.',
    })
])

# --- Help Function ---
def print_help():
    print(f"{C_BOLD}Cassandra Operations Master Script{C_RESET}")
    print("\nA unified wrapper for managing common Cassandra operational tasks on this node.")
    print(f"\n{C_YELLOW}Usage: cass-ops <command> [arguments...]{C_RESET}")
    print(f"       cass-ops <command> -- --help   (to see options for the underlying script)")

    for category, cmds in COMMANDS.items():
        print(f"\n{C_BLUE}--- {category} ---{C_RESET}")
        # Find the longest command name in the category for alignment
        longest_cmd = max(len(cmd) for cmd in cmds.keys())
        for cmd, desc in cmds.items():
            padding = ' ' * (longest_cmd - len(cmd) + 3)
            print(f"  {C_GREEN}{cmd}{C_RESET}{padding}{desc}")
    print("")

# --- Main Dispatcher ---
def main():
    if len(sys.argv) < 2 or sys.argv[1] in ('-h', '--help'):
        print_help()
        sys.exit(0)

    command = sys.argv[1]
    
    # Flatten the command map for easy lookup
    all_commands = {cmd: f'/usr/local/bin/{cmd.replace("_", "-")}.sh' for category in COMMANDS.values() for cmd in category}
    
    # Special handling for backup-guide and puppet-guide to use `less`
    if command == 'backup-guide':
        script_path = '/usr/share/doc/cassandra_pfpt/BACKUP_AND_RECOVERY_GUIDE.md'
        try:
            subprocess.run(['less', '-R', script_path], check=True)
        except FileNotFoundError:
            print(f"{C_RED}ERROR: Documentation file not found at {script_path}{C_RESET}")
            sys.exit(1)
        except subprocess.CalledProcessError:
            print(f"{C_RED}ERROR: `less` command failed to display the guide.{C_RESET}")
            sys.exit(1)
        sys.exit(0)

    if command == 'puppet-guide':
        script_path = '/usr/share/doc/cassandra_pfpt/PUPPET_ARCHITECTURE_GUIDE.md'
        try:
            subprocess.run(['less', '-R', script_path], check=True)
        except FileNotFoundError:
            print(f"{C_RED}ERROR: Documentation file not found at {script_path}{C_RESET}")
            sys.exit(1)
        except subprocess.CalledProcessError:
            print(f"{C_RED}ERROR: `less` command failed to display the guide.{C_RESET}")
            sys.exit(1)
        sys.exit(0)
    
    if command in all_commands:
        script_path = all_commands[command]
        args_to_pass = sys.argv[2:]
        
        try:
            # Use subprocess.run to execute the script and pass arguments
            # We don't capture output, allowing the called script to print directly
            result = subprocess.run([script_path] + args_to_pass, check=False)
            sys.exit(result.returncode)
        except FileNotFoundError:
            print(f"{C_RED}ERROR: The script for command '{command}' was not found at '{script_path}'.{C_RESET}")
            sys.exit(1)
        except Exception as e:
            print(f"{C_RED}An unexpected error occurred while running '{command}': {e}{C_RESET}")
            sys.exit(1)
    else:
        print(f"{C_RED}Error: Unknown command '{command}'{C_RESET}\n")
        print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()
