#!/usr/bin/env python3
# This file is managed by Puppet.

import sys
import subprocess
from argparse import ArgumentParser, RawTextHelpFormatter

# Try to import colorama, but gracefully handle its absence.
try:
    from colorama import init, Fore, Style
    init(autoreset=True)
    COLOR_ENABLED = True
except ImportError:
    # Create dummy Fore and Style objects if colorama is not installed
    class DummyColor:
        def __getattr__(self, name):
            return ""
    Fore = DummyColor()
    Style = DummyColor()
    COLOR_ENABLED = False


def print_color(text, color, bold=False, file=sys.stdout):
    """Prints text in a given color, with an option for bold."""
    if COLOR_ENABLED and file.isatty():
        bold_style = Style.BRIGHT if bold else ""
        print(f"{bold_style}{color}{text}{Style.RESET_ALL}", file=file)
    else:
        print(text, file=file)


def main():
    # Using RawTextHelpFormatter to have full control over the help message format
    parser = ArgumentParser(
        description="""Unified operations script for Cassandra.
Provides safe, robust wrappers for common operational tasks.""",
        formatter_class=RawTextHelpFormatter,
        epilog="Run 'cass-ops <command> --help' for more information on a specific command."
    )
    
    # Create a single subparser. The help text will be managed manually.
    subparsers = parser.add_subparsers(dest='command', metavar='<command>', help="""
  Status & Health Commands:
    health              Run a comprehensive health check on the local node.
    cluster-health      Quickly check cluster connectivity and nodetool status.
    disk-health         Check disk usage against warning/critical thresholds.
    version             Audit and print versions of key software.

  Node Lifecycle & Maintenance:
    stop                Safely drain and stop the Cassandra service.
    restart             Perform a safe, rolling restart of the Cassandra service.
    reboot              Safely drain Cassandra and reboot the machine.
    drain               Drain the node, flushing memtables and stopping client traffic.
    decommission        Permanently remove this node from the cluster.
    replace             Configure this NEW, STOPPED node to replace a dead node.
    rebuild             Rebuild the data on this node by streaming from another DC.

  Data Management & Repair:
    repair              Run a safe, granular repair on the node's token ranges.
    cleanup             Run 'nodetool cleanup' with safety checks.
    compact             Run 'nodetool compact' with safety checks.
    garbage-collect     Run 'nodetool garbagecollect' with safety checks.
    upgrade-sstables    Run 'nodetool upgradesstables' with safety checks.
    snapshot            Take an ad-hoc snapshot with a generated tag.

  Backup & Recovery:
    backup              Manually trigger a full, node-local backup to S3.
    incremental-backup  Manually trigger an incremental backup to S3.
    backup-status       Check the status of the last completed backup for a node.
    restore             Restore data from S3 backups. Use --help for complex options.

  Advanced & Destructive Operations:
    assassinate         Forcibly remove a dead node from the cluster ring.
    stress              Run 'cassandra-stress' via a robust wrapper.
    upgrade-check       Run pre-flight checks before a major version upgrade.
    
  Documentation:
    manual              Display the full operations manual in the terminal.
""")

    # Mapping from commands to script names
    command_map = {
        'health': 'node_health_check.sh', 'cluster-health': 'cluster-health.sh', 'disk-health': 'disk-health-check.sh', 'version': 'version-check.sh',
        'stop': 'stop-node.sh', 'restart': 'rolling_restart.sh', 'reboot': 'reboot-node.sh', 'drain': 'drain-node.sh', 'decommission': 'decommission-node.sh', 'replace': 'prepare-replacement.sh', 'rebuild': 'rebuild-node.sh',
        'repair': 'range-repair.sh', 'cleanup': 'cleanup-node.sh', 'compact': 'compaction-manager.sh', 'garbage-collect': 'garbage-collect.sh', 'upgrade-sstables': 'upgrade-sstables.sh', 'snapshot': 'take-snapshot.sh',
        'backup': 'full-backup-to-s3.sh', 'incremental-backup': 'incremental-backup-to-s3.sh', 'backup-status': 'backup-status.sh', 'restore': 'restore-from-s3.sh',
        'assassinate': 'assassinate-node.sh', 'stress': 'stress-test.sh', 'upgrade-check': 'cassandra-upgrade-precheck.sh',
        'manual': 'cassandra-manual.sh'
    }

    # Add all commands as subparsers so they appear in tab-completion and help
    for cmd, script in command_map.items():
        # Set add_help=False for commands that just pass arguments to a shell script.
        # The shell script itself can handle --help.
        subparsers.add_parser(cmd, help=f"Dispatcher for {script}", add_help=False)

    # If no command is given, print help and exit
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        return 1
    
    # Use parse_known_args to separate the command from its arguments
    args, remaining_args = parser.parse_known_args()

    if not args.command:
        print_color("Error: No command provided.", Fore.RED, bold=True, file=sys.stderr)
        parser.print_help(sys.stderr)
        return 1

    if args.command not in command_map:
        print_color(f"Error: Unknown command '{args.command}'.", Fore.RED, bold=True, file=sys.stderr)
        parser.print_help(sys.stderr)
        return 1

    script_path = f"/usr/local/bin/{command_map[args.command]}"
    
    print_color(f"Executing: {script_path} {' '.join(remaining_args)}", Fore.CYAN)
    
    try:
        # Run the underlying shell script, passing any remaining arguments
        # Set check=False to handle the return code manually
        result = subprocess.run([script_path] + remaining_args, check=False)
        return result.returncode
    except FileNotFoundError:
        print_color(f"Error: The script '{script_path}' was not found.", Fore.RED, bold=True, file=sys.stderr)
        return 127
    except Exception as e:
        print_color(f"An unexpected error occurred: {e}", Fore.RED, bold=True, file=sys.stderr)
        return 1

if __name__ == '__main__':
    sys.exit(main())
